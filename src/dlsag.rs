use crate::traits::{Link, Sign, Verify};
use alloc::vec::Vec;
use curve25519_dalek::constants;
use curve25519_dalek::ristretto::RistrettoPoint;
use curve25519_dalek::scalar::Scalar;
use digest::generic_array::typenum::U64;
use digest::Digest;
use rand_core::{CryptoRng, RngCore};

/// Dual Linkable Spontaneous Anonymous Group Signature for Ad Hoc Groups
///
/// [DLSAG: Non-Interactive Refund Transactions For Interoperable Payment Channels in Monero](https://eprint.iacr.org/2019/595.pdf)
///
/// This is a a novel linkable ring signature scheme that enables for the
/// first time refund transactions natively in Monero
///
/// Read the paper on how to use it to implement payment channels.
///
/// Please read tests at the bottom of the source code for this module for
/// examples on how to use it
pub struct DLSAG {
    challenge: Scalar,
    responses: Vec<Scalar>,
    ring: Vec<(RistrettoPoint, RistrettoPoint, Scalar)>,
    key_image: RistrettoPoint,
}

impl Sign<(Scalar, RistrettoPoint, Scalar), Vec<(RistrettoPoint, RistrettoPoint, Scalar)>>
    for DLSAG
{
    /// To sign you need `k` your private key, and `ring` which is the public keys of everyone
    /// except you. You are signing the `message`
    ///
    /// The private key `k` in this case is your private key, the public key of the other end of
    /// the channel and a random bitstring generated by hashing-to-scalar: the transaction ID, and
    /// output index.
    ///
    /// The ring contains public key pairs from the blockchain together with their random
    /// bitstrings as mentioned above.
    fn sign<
        Hash: Digest<OutputSize = U64> + Clone + Default,
        CSPRNG: CryptoRng + RngCore + Default,
    >(
        k: (Scalar, RistrettoPoint, Scalar),
        mut ring: Vec<(RistrettoPoint, RistrettoPoint, Scalar)>,
        message: &Vec<u8>,
    ) -> DLSAG {
        let mut csprng = CSPRNG::default();

        // Provers public key
        let k_point: (RistrettoPoint, RistrettoPoint, Scalar) =
            (k.0 * constants::RISTRETTO_BASEPOINT_POINT, k.1, k.2);

        let key_image: RistrettoPoint = k.2
            * k.0
            * RistrettoPoint::from_hash(Hash::default().chain(k_point.1.compress().as_bytes()));

        // Ring size (at least 4 but maximum 32)
        let n = ring.len() + 1;

        // This is the index where the prover hides key
        let secret_index = (csprng.next_u32() % n as u32) as usize;

        ring.insert(secret_index, k_point);

        let a: Scalar = Scalar::random(&mut csprng);

        let mut rs: Vec<Scalar> = (0..n).map(|_| Scalar::random(&mut csprng)).collect();

        let mut cs: Vec<Scalar> = (0..n).map(|_| Scalar::zero()).collect();

        // Hash of message is shared by all challenges H_n(m, ....)
        let mut message_hash = Hash::default();

        message_hash.input(message);

        let mut hashes: Vec<Hash> = (0..n).map(|_| message_hash.clone()).collect();

        hashes[(secret_index + 1) % n].input(
            (a * constants::RISTRETTO_BASEPOINT_POINT)
                .compress()
                .as_bytes(),
        );
        hashes[(secret_index + 1) % n].input(
            (a * ring[secret_index].2
                * RistrettoPoint::from_hash(
                    Hash::default().chain(k_point.1.compress().as_bytes()),
                ))
            .compress()
            .as_bytes(),
        );
        cs[(secret_index + 1) % n] = Scalar::from_hash(hashes[(secret_index + 1) % n].clone());

        let mut i = (secret_index + 1) % n;

        loop {
            hashes[(i + 1) % n].input(
                ((rs[i % n] * constants::RISTRETTO_BASEPOINT_POINT) + (cs[i % n] * ring[i % n].0))
                    .compress()
                    .as_bytes(),
            );
            hashes[(i + 1) % n].input(
                ((rs[i % n]
                    * ring[i % n].2
                    * RistrettoPoint::from_hash(
                        Hash::default().chain(ring[i % n].1.compress().as_bytes()),
                    ))
                    + (cs[i % n] * key_image))
                    .compress()
                    .as_bytes(),
            );
            cs[(i + 1) % n] = Scalar::from_hash(hashes[(i + 1) % n].clone());

            if secret_index >= 1 && i % n == (secret_index - 1) % n {
                break;
            } else if secret_index == 0 && i % n == n - 1 {
                break;
            } else {
                i = (i + 1) % n;
            }
        }

        rs[secret_index] = a - (cs[secret_index] * k.0);

        return DLSAG {
            challenge: cs[0],
            responses: rs,
            ring: ring,
            key_image: key_image,
        };
    }
}

impl Verify for DLSAG {
    /// To verify a `signature` you need the `message` too
    fn verify<Hash: Digest<OutputSize = U64> + Clone + Default>(
        signature: DLSAG,
        message: &Vec<u8>,
    ) -> bool {
        let mut reconstructed_c: Scalar = signature.challenge;
        let n = signature.ring.len();
        for j in 0..n {
            let mut h: Hash = Hash::default();
            h.input(message);
            h.input(
                ((signature.responses[j] * constants::RISTRETTO_BASEPOINT_POINT)
                    + (reconstructed_c * signature.ring[j].0))
                    .compress()
                    .as_bytes(),
            );

            h.input(
                (signature.responses[j]
                    * signature.ring[j].2
                    * RistrettoPoint::from_hash(
                        Hash::default().chain(signature.ring[j].1.compress().as_bytes()),
                    )
                    + (reconstructed_c * signature.key_image))
                    .compress()
                    .as_bytes(),
            );
            reconstructed_c = Scalar::from_hash(h);
        }

        return signature.challenge == reconstructed_c;
    }
}

impl Link for DLSAG {
    /// This is for linking two signatures and checking if they are signed by the same person
    fn link(signature_1: DLSAG, signature_2: DLSAG) -> bool {
        return signature_1.key_image == signature_2.key_image;
    }
}

#[cfg(test)]
mod test {
    extern crate blake2;
    extern crate rand;
    extern crate sha2;
    extern crate sha3;

    use super::*;
    use blake2::Blake2b;
    use curve25519_dalek::ristretto::RistrettoPoint;
    use curve25519_dalek::scalar::Scalar;
    use rand::rngs::OsRng;
    use sha2::Sha512;
    use sha3::Keccak512;

    #[test]
    fn dlsag() {
        let mut csprng = OsRng::default();
        let k: (Scalar, RistrettoPoint, Scalar) = (
            Scalar::random(&mut csprng),         // The prover's private key
            RistrettoPoint::random(&mut csprng), // The public key of the other end of the channel
            // According to the paper this should be a random
            // bitstring generated by hashing transaction ID, and output index.
            // It is simulated here using a random bitstring
            Scalar::random(&mut csprng),
        );
        let n = (csprng.next_u32() % 29 + 4) as usize;
        // Simulate randomly chosen Public keys (Prover will insert her public key here later)
        let ring: Vec<(RistrettoPoint, RistrettoPoint, Scalar)> = (0..(n - 1)) // Prover is going to add her key into this mix
            .map(|_| {
                (
                    RistrettoPoint::random(&mut csprng),
                    RistrettoPoint::random(&mut csprng),
                    Scalar::random(&mut csprng),
                )
            })
            .collect();
        let message: Vec<u8> = b"This is the message".iter().cloned().collect();

        {
            let signature = DLSAG::sign::<Sha512, OsRng>(k, ring.clone(), &message);
            let result = DLSAG::verify::<Sha512>(signature, &message);
            assert!(result);
        }

        {
            let signature = DLSAG::sign::<Keccak512, OsRng>(k, ring.clone(), &message);
            let result = DLSAG::verify::<Keccak512>(signature, &message);
            assert!(result);
        }

        {
            let signature = DLSAG::sign::<Blake2b, OsRng>(k, ring.clone(), &message);
            let result = DLSAG::verify::<Blake2b>(signature, &message);
            assert!(result);
        }

        let another_ring: Vec<(RistrettoPoint, RistrettoPoint, Scalar)> = (0..(n - 1)) // Prover is going to add her key into this mix
            .map(|_| {
                (
                    RistrettoPoint::random(&mut csprng),
                    RistrettoPoint::random(&mut csprng),
                    Scalar::random(&mut csprng),
                )
            })
            .collect();
        let another_message: Vec<u8> = b"This is another message".iter().cloned().collect();
        let signature_1 = DLSAG::sign::<Blake2b, OsRng>(k, another_ring.clone(), &another_message);
        let signature_2 = DLSAG::sign::<Blake2b, OsRng>(k, ring.clone(), &message);
        let result = DLSAG::link(signature_1, signature_2);
        assert!(result);
    }
}
